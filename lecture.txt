// 1. парсинг - вытаскиваем из строки
// 2. обработка - то что вытащили - обрабатываем
// принтф возвращает кол-во выведенных символов = байтов.
// для парсинга аргументов - va_start, возвращает длину
// в ф-ию парсинга завожу структуру (интами), все что может быть - d,s,c
цикл парсинга начинается, цикл заканчивается - когда заканивается строка
прежд чем паристь - инициализируем структуру - тип, ширина, точноть, минус, ссылка на др переменную
при парсинге:
находим процент
встрчаем пробел? всталвяем
парсим дальше флаги - новая ф-ия - заводим форматную строку, счетчик, все флаги, аругменты
далее - считываем по фарматной строке - цифра, тип или флаг
если 0 - нет ширины и точности - вставляем флаг 0, пересчелкиваем на 1 - исп для ширины
если точка - имеем дето с точностью. перепрыгиваем через точку
вопрос - есть ли дальше переменная?
если да - считываем, если нет - обнуляем показатель точности и конвертируем чем угодно
на выходе - число, которое означает точность кроме запятой
(что-то где-то навалит кучу нулей)
минимальное значени - точностью, максимальное - шириной
ширина - задает размер поля - кол-во символов нудно вывести максимально
у ширины лва показателя - отсутсвубщий и ноль
если ноль - то забиваем ширину перед(после)? числа нулями
у точности - модет не быть, ноль или цифра. отриц точность - обрабатывается как положительная и ставится знак минус
ищем минус - есть - в структуру забиваем минус(флаг) и переинициал параметр с нулем
ширина. еси есть * - смотрим, что там есть. в параметр точность запихиваем то, что в сл аргументе
если отриц ширина - перещелкиваем единицу, параметр минус и умножаем отриц число на минус   - приводим к положительную. переиниц параметр ноль
если после % или пробела звездочка, то опр ширину как переменную, которая спрятана в строке
если не *, то цифра - это ширина, проверяем, не перещелкнула ли звездочка
на каждом этапе вернуть структуру с фалгами

обработка:
если после % еще олин - то выводим один %
если есть минус - то прцент смещаем влево. ставим с доб точностью и добавляем ширину
ф-ия - разместить строку с точностью
ф-ия - добавить ширину в конец
если нет флага минус - то просто ставим процент с добавленной точностью
в конце ф-ии - возвращаем длину полученную (длина+точность и все такое, там % быйты, нули и пробелы)
- если надо вывести char, то делаем то же, что и с процентом (минус обрабатываем)
- если надо вывести строку. есть строка? если нет - то нуль(в линуксе нилл выводится). если налл - то все равно надо резать, опр ширину, точность и все такое
если есть точность >=0 и если она больше длины строки - то точность ставим равной длине строки
если есть минус - снова увязываем его с точностью
если есть точность - ширина ьез нулей и строка с флагом точности
если нет точнсти - то строку добавляем с общитанной точностью до конца строки ( используем маллоки)
если нет минуса - проверяем на точность
если нет минуса, но есть точность - доб ширину, а потом выводим строку
нет точности, го нет минуса - выводим строку с обработанной точностью и все
и мерием - сколько мы вывели - потом все суммируем
к счетчику делаем += - это сократит кол-во строк
	поинтер - выведение алреса, 16-ричный - %p  - беззнаковый лонг, так как в инт может не поместиться
при его обработке - маллочим строку, если равен нулю - выводим нач показатель 0х с доьавленным флагом точность - может вывести с нулми (?)
потом доб ширину, даже если ничего нет
есть ли ансигнед лонг - если нет  - выводим ноль и все
в ансигнед лонг передаем спарсиный алрес
если цифра - делим на 16, считаем кол-во разрядов и т/д/ - делаем конвертацию. если рез-ат деления больше 10 - то бувка, наоорот - число - по таблице аски
имеем готовую строку, к которой надо доавить ширину и точность
ставим 0х с доб точнстью
если есть точность - доб в две ф-ии (?)
если нет точности - строка с доб флагом
эти ф-ии постоянно встречаются - но можно из них сделать одну большую

логика для интегер
берем инт из аргумента и флаги
делаем строку, чтобы потом размолочить, буферизуем инт, если надо будет его как-то деить, или еще что-то
есои инт = 0, то добавляем ширину
если инт < 0 - есть ли нуль и отриц точность
обрабатываем флаги
используется итоа
получилась готовая строка, которую надо обработать на ширину и точность - обращаемся к структуре
если есть точность - доб ширину и строку
провряем на пачку условий: провер ширину, точность

флаг u
- обрабатываем беззнаковый инт (d и i - одинаковые)
беззнаковый - если на входе беззнаковый ансигнед инт
на вход он может завестить как отрицательный - надо тогда получить модуль
если нулевая точность и инт = 0 - доб ширину
строке присваиваем итоа (ft_itoa)
если есть точность - доб ширину и доб строку
если нет минуса и есть точность и она меньше длины строки - то приравниваем и дальше определяем
а дальше работа такая же как и с интом
в конце докладываем ширину и точность

х и Х
делаем строку и беззнаковый инт
если больше буквы - то налево, маленьки - направо
пример на маленькой:
так как 16-ая система, то приводим к безнаковому лонгу
если 0 - строка 0
если ансигнед лонг есть - конвертируем (как и с поинтом)
putnbr(base) - можно решить побитной маской - так быстрее, оптимизация
проверка на минус
на точност - если есть - докладываем нули

		ширина - кол-во знаков, которые можно вывести максимально
		у нее два подпараметра - либо пробел, либо ноль
		если определяется ширина, после вывода числа или строки - добиваем это пробелами
		если есть ноль - добиваем нуля

		точность -
		в случае с целочислами с типами, определяет миним кол-во знаков, которые надо вывести.
		и если точность больше этого кол-ва знаков, то добивает нулями слева
		если меньше - то обрезает до размера строки

	как взаимодействуют точность и ширина:
	сперва выводим строку с обработанной точностью, а потом, в зависимости от точности(или ширины, не поняла) - дополняем если надо - в ф-ии должен быть параметр, который сможет если че что-то обрезать
	если ширина меньше строки - обрезаем строку
	если инт - то не орезаем, выводим целое число

лайфак - если много переменных, то модно использовать структуру - там может быть сколько угодно


когда указывается ширина поля, то по умолчанию данные выравниваются по правому краю. это удобно,
так как при дробных числах, десятки под дестяками, целыми под целыми и так далее
если надо выравнить по левому краю - то это знак минус перед числом количеством знакомест
%f - по умолчанию выводит 6 чисел после запятой. если надо больше/меньше - то надо использовать точность

флаг 0 - заполнение нулями в начале
 игнорируется если есть минус и игнорится для d, i, o, u, X и x, если указана точность;